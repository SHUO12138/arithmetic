# arithmetic
学习算法的库
1.模拟原码用数组实现 ArrayList
2.用链表实现二叉树BeeTree部分功能
查找
    线性表查找
        1.顺序查找
        2.二分法   
            顺序结构 有序
    查找树
        平衡二叉树
            左右子树高度差不差过1
            平衡二叉树是为了减少二叉树的的查找层次
            实现 
              AVL树 
                 自平衡二叉树
              红黑树
                  1.每个节点不是黑就是红
                  2.根节点为 黑色
                  3.每个叶子节点是黑色 指为空的叶子节点
                  4.节点为红色 子节点必须为黑色
                  5.一个节点到子孙节点的所有路径包含相同数目的黑节点
                  java TreeSet TreeMap底层用的红黑树
                    有序 (中序遍历) O(log n) 存储有序的数据
                    AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；
                    红黑是弱平衡的，用非严格的平衡来换取增删节点时候旋转次数的降低；
                    所以简单说，搜索的次数远远大于插入和删除，那么选择AVL树，如果搜索，插入删除次数几乎差不多，应该选择RB树。
              B树 balanced（平衡树）
                    分叉更多
                    降低深度来提高查找数据
                    数据量比较大  不能一次读完
                    一次排除(n-1)/n    
              B+树
                数据库索引默认数据结构为B+树
              替罪羊树
              伸展树
         
哈希表查找
    hashtable 也叫散列表 快 非常快
    增加快 
        1.计算哈希码 整数哈希码就是它的数
        2.套上哈希函数 =x%11
        3.找对对应数组 将数据放入链表
        4.无重复 无序
    结构 数组+链表
    查询 和添加时差不多
    不需要比较就可以找到需要的内容
    
    
 java 中的查找树和哈希表
    TreeSet TreeMap 红黑树
    
  1.7之前都是 数组加链表
  1.8 以后 长度超过8 用红黑树提高查询效率  
  
  装填因子=表中记录数/哈希表长度  默认 0.75
  默认初始化长度 1<<4  16
  
  
 排序算法
 比较排序                                                             非比较
 插入排序                           选择排序     交换排序             归并排序       计数  基数
 直接插入  希尔排序  折半插入排序    选择  堆    冒泡排序 快速排序    归并排序
    
    
    
    
    
快速排序  冒泡排序的改进  最好的内排序  涉及到分冶和递归
基本思想
1.数列中选一个基准数
2.分区  大的全放左边  下的全放右边（分区）
3.重复第一 第二步 对左右区间进行排序 直到各区间只有一个数

